import _extends from "@babel/runtime/helpers/extends";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import React from 'react';
import PropTypes from 'prop-types';
import { useForkRef } from '../utils/reactHelpers';
import debounce from 'debounce'; // < 1kb payload overhead when lodash/debounce is > 3kb.

function getStyleValue(computedStyle, property) {
  return parseInt(computedStyle[property], 10) || 0;
}

var useEnhancedEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;
/**
 * @ignore - internal component.
 *
 * To make public in v4+.
 */

var Textarea = React.forwardRef(function Textarea(props, ref) {
  var onChange = props.onChange,
      rowsMax = props.rowsMax,
      rowsMin = props.rowsMin,
      style = props.style,
      value = props.value,
      other = _objectWithoutProperties(props, ["onChange", "rowsMax", "rowsMin", "style", "value"]);

  var _React$useRef = React.useRef(value != null),
      isControlled = _React$useRef.current;

  var inputRef = React.useRef();

  var _React$useState = React.useState({}),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      state = _React$useState2[0],
      setState = _React$useState2[1];

  var handleRef = useForkRef(ref, inputRef);
  var syncHeight = React.useCallback(function () {
    var input = inputRef.current;
    var savedValue = input.value;
    var savedHeight = input.style.height;
    var savedOverflow = input.style.overflow;
    input.style.overflow = 'hidden';
    input.style.height = '0'; // The height of the inner content

    input.value = savedValue || props.placeholder || 'x';
    var innerHeight = input.scrollHeight;
    var computedStyle = window.getComputedStyle(input);
    var boxSizing = computedStyle['box-sizing']; // Measure height of a textarea with a single row

    input.value = 'x';
    var singleRowHeight = input.scrollHeight; // The height of the outer content

    var outerHeight = innerHeight;

    if (rowsMin != null) {
      outerHeight = Math.max(Number(rowsMin) * singleRowHeight, outerHeight);
    }

    if (rowsMax != null) {
      outerHeight = Math.min(Number(rowsMax) * singleRowHeight, outerHeight);
    }

    outerHeight = Math.max(outerHeight, singleRowHeight);

    if (boxSizing === 'content-box') {
      outerHeight -= getStyleValue(computedStyle, 'padding-bottom') + getStyleValue(computedStyle, 'padding-top');
    } else if (boxSizing === 'border-box') {
      outerHeight += getStyleValue(computedStyle, 'border-bottom-width') + getStyleValue(computedStyle, 'border-top-width');
    }

    input.style.overflow = savedOverflow;
    input.style.height = savedHeight;
    input.value = savedValue;
    setState(function (prevState) {
      // Need a large enough different to update the height.
      // This prevents infinite rendering loop.
      if (innerHeight > 0 && Math.abs((prevState.innerHeight || 0) - innerHeight) > 1) {
        return {
          innerHeight: innerHeight,
          outerHeight: outerHeight
        };
      }

      return prevState;
    });
  }, [setState, rowsMin, rowsMax, props.placeholder]);
  React.useEffect(function () {
    var handleResize = debounce(function () {
      syncHeight();
    }, 166); // Corresponds to 10 frames at 60 Hz.

    window.addEventListener('resize', handleResize);
    return function () {
      handleResize.clear();
      window.removeEventListener('resize', handleResize);
    };
  }, [syncHeight]);
  useEnhancedEffect(function () {
    syncHeight();
  });

  var handleChange = function handleChange(event) {
    if (!isControlled) {
      syncHeight();
    }

    if (onChange) {
      onChange(event);
    }
  };

  return React.createElement("textarea", _extends({
    value: value,
    onChange: handleChange,
    ref: handleRef,
    style: _extends({
      height: state.outerHeight,
      overflow: state.outerHeight === state.innerHeight ? 'hidden' : null
    }, style)
  }, other));
});
process.env.NODE_ENV !== "production" ? Textarea.propTypes = {
  /**
   * @ignore
   */
  className: PropTypes.string,

  /**
   * @ignore
   */
  onChange: PropTypes.func,

  /**
   * @ignore
   */
  placeholder: PropTypes.string,

  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  rowsMax: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  rowsMin: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /**
   * @ignore
   */
  style: PropTypes.object,

  /**
   * @ignore
   */
  value: PropTypes.any
} : void 0;
export default Textarea;